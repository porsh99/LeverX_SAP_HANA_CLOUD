'use strict';

/* jslint indent: 4 */

const async = require('async');

const hdb = require('../hdbAsync.js');
const logger = require('../logger.js');
const utils = require('../utils.js');
const paths = require('../paths.js');

const {
  SQLGrantorStrategy,
  HDIContainerGrantorStrategy,
  ProcedureGrantorStrategy
} = require('./strategies');

function selectSchema() {
  // return the first non-undefined argument
  for (let i = 0; i < arguments.length; ++i) {
    const schema = arguments[i];
    if (schema !== undefined) {
      return schema;
    }
  }
  return '';
}

function check_array_is_array_and_not_empty(to_check, var_name){
  if (!utils.isArray(to_check)){
    throw new Error(`Expected ${var_name} to be of type Array. Found: ${Object.prototype.toString.call(to_check)}`);
  }

  return to_check.length > 0;
}

function grantPrivileges(client, grantor_type, privileges, grantee, grantor_schema, grantor_remote, grantor_procedure, grantor_procedure_schema, cb) {
  try {
    const tasks = [];

    let grantorStrategy;
    if (grantor_type === 'hdi') {
      grantorStrategy = new HDIContainerGrantorStrategy(client, tasks, grantor_schema);
    } else if (grantor_type === 'procedure') {
      grantorStrategy = new ProcedureGrantorStrategy(client, tasks, grantor_procedure, grantor_procedure_schema);
    } else {
      grantorStrategy = new SQLGrantorStrategy(client, tasks);
    }

    grantorStrategy.initialize();

    /*
     * the rule for schema selection is:
     * 1. obj.schema
     * 2. obj.reference, only used for schema_privileges
     * 3. grantor_schema
     */

    if (privileges.roles) {
      /*
       * roles is supported for backwards compatibility
       * string format: "roles": [ "X", "Y" ]
       * object format: "roles": [ { "names": [ "X", "Y" ], "roles": [ "X", "Y" ], "roles_with_admin_option": [ "A", "B" ] } ]
       */
      const string_format_roles = [];
      privileges.roles.forEach(function(obj) {
        if (typeof obj === 'string') {
          string_format_roles.push(obj);
        } else {
          if (obj.names) {
            if (check_array_is_array_and_not_empty(obj.names, 'names')){
              grantorStrategy.grantGlobalRoles(obj.names, grantee, false);
            }
          }
          if (obj.roles) {
            if (check_array_is_array_and_not_empty(obj.roles, 'roles')){
              grantorStrategy.grantGlobalRoles(obj.roles, grantee, false);
            }
          }
          if (obj.roles_with_admin_option) {
            if (check_array_is_array_and_not_empty(obj.roles_with_admin_option, 'roles_with_admin_option')){
              grantorStrategy.grantGlobalRoles(obj.roles_with_admin_option, grantee, true);
            }
          }
        }
      });

      if (string_format_roles.length > 0) {
        grantorStrategy.grantGlobalRoles(string_format_roles, grantee, false);
      }
    }

    if (privileges.global_roles) {
      /*
       * global_roles is supported for symmetry with hdbrole
       * string format: "global_roles": [ "X", "Y" ]
       * object format: "global_roles": [ { "names": [ "X", "Y" ], "roles": [ "X", "Y" ], "roles_with_admin_option": [ "A", "B" ] } ]
       */
      const string_format_global_roles = [];
      privileges.global_roles.forEach(function(obj) {
        if (typeof obj === 'string') {
          string_format_global_roles.push(obj);
        } else {
          if (obj.names) {
            if (check_array_is_array_and_not_empty(obj.names, 'names')){
              grantorStrategy.grantGlobalRoles(obj.names, grantee, false);
            }
          }
          if (obj.roles) {
            if (check_array_is_array_and_not_empty(obj.roles, 'roles')){
              grantorStrategy.grantGlobalRoles(obj.roles, grantee, false);
            }
          }
          if (obj.roles_with_admin_option) {
            if (check_array_is_array_and_not_empty(obj.roles_with_admin_option, 'roles_with_admin_option')){
              grantorStrategy.grantGlobalRoles(obj.roles_with_admin_option, grantee, true);
            }
          }
        }
      });

      if (string_format_global_roles.length > 0) {
        grantorStrategy.grantGlobalRoles(string_format_global_roles, grantee, false);
      }
    }

    if (privileges.system_privileges) {
      /*
       * string format: "system_privileges": [ "X", "Y" ]
       * object format: "system_privileges": [ { "privileges": [ "X", "Y" ], "privileges_with_admin_option": [ "A", "B" ] } ]
       */
      const string_format_privileges = [];
      privileges.system_privileges.forEach(function(obj) {
        if (typeof obj === 'string') {
          string_format_privileges.push(obj);
        } else {
          if (obj.privileges) {
            if (check_array_is_array_and_not_empty(obj.privileges, 'privileges')){
              grantorStrategy.grantSystemPrivileges(obj.privileges, grantee, false);
            }
          }
          if (obj.privileges_with_admin_option) {
            if (check_array_is_array_and_not_empty(obj.privileges_with_admin_option, 'privileges_with_admin_option')){
              grantorStrategy.grantSystemPrivileges(obj.privileges_with_admin_option, grantee, true);
            }
          }
        }
      });

      if (string_format_privileges.length > 0) {
        grantorStrategy.grantSystemPrivileges(string_format_privileges, grantee, false);
      }
    }

    if (privileges.schema_privileges) {
      privileges.schema_privileges.forEach(function(obj) {
        if (obj.privileges) {
          if (check_array_is_array_and_not_empty(obj.privileges, 'privileges')){
            grantorStrategy.grantSchemaPrivileges(obj.privileges, selectSchema(obj.schema, obj.reference, grantor_schema), grantee, false);
          }
        }
        if (obj.privileges_with_grant_option) {
          if (check_array_is_array_and_not_empty(obj.privileges_with_grant_option, 'privileges_with_grant_option')){
            grantorStrategy.grantSchemaPrivileges(obj.privileges_with_grant_option, selectSchema(obj.schema, obj.reference, grantor_schema), grantee, true);
          }
        }
      });
    }

    if (privileges.object_privileges) {
      privileges.object_privileges.forEach(function(obj) {
        if (obj.privileges) {
          if (check_array_is_array_and_not_empty(obj.privileges, 'privileges')){
            grantorStrategy.grantSchemaObjectPrivileges(obj.privileges, selectSchema(obj.schema, grantor_schema), obj.name, grantee, false);
          }
        }
        if (obj.privileges_with_grant_option) {
          if (check_array_is_array_and_not_empty(obj.privileges_with_grant_option, 'privileges_with_grant_option')){
            grantorStrategy.grantSchemaObjectPrivileges(obj.privileges_with_grant_option, selectSchema(obj.schema, grantor_schema), obj.name, grantee, true);
          }
        }
      });
    }

    if (privileges.global_object_privileges) {
      privileges.global_object_privileges.forEach(function(obj) {
        let name = obj.name;
        if (typeof name === 'undefined' && obj.type === 'REMOTE SOURCE') {
          name = grantor_remote;
        }

        if (obj.privileges) {
          if (check_array_is_array_and_not_empty(obj.privileges, 'privileges')){
            grantorStrategy.grantGlobalObjectPrivileges(obj.privileges, name, obj.type, grantee, false);
          }
        }
        if (obj.privileges_with_grant_option) {
          if (check_array_is_array_and_not_empty(obj.privileges_with_grant_option, 'privileges_with_grant_option')){
            grantorStrategy.grantGlobalObjectPrivileges(obj.privileges_with_grant_option, name, obj.type, grantee, true);
          }
        }
      });
    }

    if (privileges.schema_roles) {
      /*
       * string format: "schema_roles": [ "X", "Y" ]
       * object format: "schema_roles": [ { "names": [ "X", "Y" ], "roles": [ "X", "Y" ], "roles_with_admin_option": [ "A", "B" ] } ]
       */
      const string_format_schema_roles = [];
      privileges.schema_roles.forEach(function(obj) {
        if (typeof obj === 'string') {
          string_format_schema_roles.push(obj);
        } else {
          if (obj.names) {
            if (check_array_is_array_and_not_empty(obj.names, 'names')){
              grantorStrategy.grantSchemaRoles(selectSchema(obj.schema, grantor_schema), obj.names, grantee, false);
            }
          }
          if (obj.roles) {
            if (check_array_is_array_and_not_empty(obj.roles, 'roles')){
              grantorStrategy.grantSchemaRoles(selectSchema(obj.schema, grantor_schema), obj.roles, grantee, false);
            }
          }
          if (obj.roles_with_admin_option) {
            if (check_array_is_array_and_not_empty(obj.roles_with_admin_option, 'roles_with_admin_option')){
              grantorStrategy.grantSchemaRoles(selectSchema(obj.schema, grantor_schema), obj.roles_with_admin_option, grantee, true);
            }
          }
        }
      });

      if (string_format_schema_roles.length > 0) {
        grantorStrategy.grantSchemaRoles(grantor_schema, string_format_schema_roles, grantee, false);
      }
    }



    if (privileges.container_roles) {
      if (check_array_is_array_and_not_empty(privileges.container_roles, 'container_roles')){
        grantorStrategy.grantSchemaRoles(grantor_schema, privileges.container_roles, grantee, false);
      }
    }

    grantorStrategy.finalize();

    async.series(tasks, cb);
  } catch (err) {
    cb(err);
  }
}

function grantUsers(privileges, grantor, fileName, creds, targetCreds, container, grantee, cb) {
  try {
    const tasks = [];
    let grantor_type;

    if (creds.type !== undefined) {
      // if the grantor object contains a type field, then use this for selecting the grantor's type
      if (creds.type === 'hdi' || creds.type === 'sql' || creds.type === 'procedure' || creds.type === 'ignore') {
        grantor_type = creds.type;
      } else {
        throw new Error("unknown grantor type, known grantor types are 'hdi', 'sql', 'procedure', 'ignore'");
      }
    } else {
      // otherwise, fallback to old auto-sensing for sql and hdi types
      grantor_type = 'sql';
      if (creds.hdi_user) {
        grantor_type = 'hdi';
      }
    }

    let host = creds.host;
    let port = creds.port;
    let hosts = creds.db_hosts;
    let certificate = creds.certificate;

    if (!Array.isArray(hosts) && host === undefined && port === undefined && certificate === undefined) {
      // host, port, certificate are optional in the service credentials, fallback to target credentials if undefined
      host = targetCreds.host;
      port = targetCreds.port;
      hosts = targetCreds.db_hosts;
      certificate = targetCreds.certificate;
    }

    let user = creds.user;
    let password = creds.password;
    if (grantor_type === 'hdi') {
      user = creds.hdi_user;
      password = creds.hdi_password;
    }

    logger.log(`  Using service "${  grantor  }" of type "${  grantor_type  }"`);

    if (grantor_type === 'ignore') {
      cb(null);
      return;
    }

    const client = hdb(host, port, user, password, certificate, hosts);

    tasks.push(client.connect());
    if (creds.schema && grantor_type !== 'procedure') {
      tasks.push(client.setSchema(creds.schema));
    }

    if (privileges.object_owner) {
      tasks.push(function(cb) {
        grantPrivileges(client, grantor_type, privileges.object_owner, container, creds.schema, creds.remote, creds.procedure, creds.procedure_schema, cb);
      });
    }

    if (privileges.application_user) {
      tasks.push(function(cb) {
        grantPrivileges(client, grantor_type, privileges.application_user, grantee, creds.schema, creds.remote, creds.procedure, creds.procedure_schema, cb);
      });
    }

    tasks.push(client.disconnect());

    async.series(tasks, function(err, results) {
      client.end();

      if (err) { // add information about grantor service & underlying user
        err.message += `\ngrantor service: "${  grantor  }", type: "${  grantor_type  }", user: "${  user  }"`;
        if (grantor_type === 'hdi') {
          err.message += ' (hdi_user)';
        }
        if (grantor_type === 'procedure') {
          err.message += `, procedure: "${  creds.procedure  }"`;
          if (creds.procedure_schema) {
            err.message += `, procedure_schema: "${  creds.procedure_schema  }"`;
          }
        }

        err.message += `\nfile name: ${  fileName}`;
      }

      cb(err, results);
    });
  } catch (err) {
    cb(err);
  }
}

function grantFile(services, root, fileName, container, grantee, cb) {
  try {
    const  tasks = [];

    fileName = paths.join(root, paths.clientPath(fileName));

    const file = utils.readJSONFile(fileName);

    const targetCreds = services.getTargetCreds();

    Object.keys(file).forEach(function(grantor) {
      let creds;
      try {
        creds = services.getCreds(grantor);
      } catch (err) {
        cb(err);
        return;
      }

      logger.trace('grantor', file[grantor]);

      tasks.push(function(cb) {
        grantUsers(file[grantor], grantor, fileName, creds, targetCreds, container, grantee, cb);
      });
    });

    async.series(tasks, cb);
  } catch (err) {
    cb(err);
  }
}

// grant target container oo and target container access role
exports.grant = function(options, services, content, container, grantee, cb) {
  try {
    let
      tasks = [],
      fileNames;

    logger.logTimerInit('grants-files', 'Processing grants files...');

    fileNames = content.synonymGrantorFiles();
    logger.trace('grants files:', fileNames);

    fileNames.forEach(function(fileName) {
      if (options.workingSet.matchesPath(fileName)) {
        tasks.push(logger.logfn(` Processing "${  fileName  }"...`));
        tasks.push(function(cb) {
          grantFile(services, content.root, fileName, container, grantee, cb);
        });
        tasks.push(logger.logfn(` Processing "${  fileName  }"... ok`));
      }
    });

    tasks.push(logger.logfnTimerDelta('grants-files', 'Processing grants files... ok'));

    async.series(tasks, function(err, results) {
      cb(err, {
        task: 'synonym',
        results: results
      });
    });
  } catch (err) {
    cb(err);
  }
};
