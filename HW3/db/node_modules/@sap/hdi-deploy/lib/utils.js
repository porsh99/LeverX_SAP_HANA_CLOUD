'use strict';

/* jslint indent: 4 */

const fs = require('fs');
const paths = require('./paths.js');
const strip_json_comments = require('./json-comment-stripper');

/**
 * Read the given file. Strip comments from the file before parsing it as JSON.
 *
 * @param {String} filename File to read.
 * @returns {Object} The parsed file.
 */
exports.readJSONFile = function (filename) {
  const raw_stripped_file = strip_json_comments(fs.readFileSync(filename, 'utf8'));
  let file;

  try {
    file = JSON.parse(raw_stripped_file);
  } catch (error) {
    throw new Error(`Could not parse JSON file "${filename}": ${error}`);
  }

  return file;
};

/**
 * <a>.<b> turns into <a>"."<b>. This assumes that the outer "" will be added at a later stage.
 *
 * @param {any} name Name to quote.
 * @returns {String} Quoted name.
 */
function quote_dot(name){
  const parts = name.split('.');
  if (parts.length > 2){
    throw new Error(`There were multiple "." found in name "${  name  }". There can only be at most one ".".`);
  } else if (parts.length === 2){
    name = `${parts[0]  }"."${  parts[1]}`;
  }
  return name;
}


exports.identifier = function(name) {
  // escape " inside identifiers to ""
  name = name.replace(/\"/g, '""');
  /*
   * Escape System privilege with a dot like a schema local role.
   * surround result with "..."
   */
  return `"${  quote_dot(name)  }"`;
};

exports.quote_dot_in_system_privilege_for_procedure = function(name){
  const parts = name.split('.');
  if (parts.length === 2){
    return `"${ quote_dot(name) }"`;
  } else {
    return name;
  }
};

/*
 * Checks if variable is an Array.
 *
 * @param {any} variable Var to check.
 * @returns {boolean} True or false.
 */
function isArray(variable){
  return (variable instanceof Array || Object.prototype.toString.call(variable) === '[object Array]');
}

exports.isArray = isArray;

/**
 * Checks if the given file is a hdbsynonymgrantor or hdbgrants file.
 *
 * @param {String} file File to check.
 * @returns {boolean} True if it's a grantor file.
 */
function isGrantorFile(file) {
  const ext = paths.extname(file);
  if (ext !== '') {
    return ext === '.hdbsynonymgrantor' || ext === '.hdbgrants';
  } else {
    const base = paths.basename(file);
    return base === '.hdbgrants';
  }
}
exports.isGrantorFile = isGrantorFile;

/**
 * Check if the file is deployable.
 * This is used to filter out non-deployable files.
 *
 * @param {String} file File to check.
 * @returns {boolean} True if the file is deplayble.
 */
function isDeployableFile(file) {
  return !isGrantorFile(file);
}

exports.isDeployableFile = isDeployableFile;

/**
 * Check if the file is a .hdbsynonymtemplate file.
 *
 * @param {String} file The name of the file
 * @returns {boolean} True if it's a .hdbsynonymtemplate file.
 */
function isSynonymTemplateFile(file) {
  return paths.extname(file) === '.hdbsynonymtemplate';
}

exports.isSynonymTemplateFile = isSynonymTemplateFile;

/**
 * Check if the file is a .hdbsynonymconfig file.
 *
 * @param {String} file The name of the file
 * @returns {boolean} True if it's a .hdbsynonymconfig file.
 */
function isSynonymConfigFile(file) {
  return paths.extname(file) === '.hdbsynonymconfig';
}

exports.isSynonymConfigFile = isSynonymConfigFile;

/**
 * Build the filename of the hdbsynonymconfig file for a given hdbsynonymtemplate file.
 *
 * @param {any} file The name of the hdbsynonymtemplate
 * @returns {String} The hdbsynonymconfig filename.
 */
exports.rename_synonymtemplate_to_config = function (file) {
  return paths.serverPath(paths.join(paths.dirname(file), `${paths.basename(file, '.hdbsynonymtemplate')}.hdbsynonymconfig`));
};
